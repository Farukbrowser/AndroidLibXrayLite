package libv2ray

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net"
	"os"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/xtls/xray-core/app/dispatcher"
	"github.com/xtls/xray-core/app/proxyman"
	"github.com/xtls/xray-core/app/stats"
	"github.com/xtls/xray-core/common/serial"
	"github.com/xtls/xray-core/core"
	"github.com/xtls/xray-core/features/inbound"
	"github.com/xtls/xray-core/features/outbound"
	"github.com/xtls/xray-core/features/policy"
	"github.com/xtls/xray-core/features/routing"
	statsFeature "github.com/xtls/xray-core/features/stats"
	"github.com/xtls/xray-core/infra/conf"
	"github.com/xtls/xray-core/transport/internet"
)

// CoreController manages the Xray core instance and FastDNS functionality
type CoreController struct {
	coreInstance    *core.Instance
	coreMutex       sync.Mutex
	IsRunning       bool
	statsManager    statsFeature.Manager
	fastDNSManager  *FastDNSManager
}

// CoreCallbackHandler defines the interface for handling core events
type CoreCallbackHandler interface {
	OnCoreStarted()
	OnCoreStopped()
	OnCoreError(error)
}

// NewCoreController creates a new CoreController instance with FastDNS support
func NewCoreController() *CoreController {
	// Initialize FastDNS manager
	fastDNSManager := NewFastDNSManager()
	
	// Try to initialize FastDNS with default resolvers
	if err := InitGlobalFastDNS(); err != nil {
		log.Printf("Warning: Failed to initialize FastDNS: %v", err)
	}

	return &CoreController{
		IsRunning:      false,
		fastDNSManager: fastDNSManager,
	}
}

// StartLoop starts the Xray core with the given configuration
func (x *CoreController) StartLoop(configBytes []byte) error {
	x.coreMutex.Lock()
	defer x.coreMutex.Unlock()

	if x.IsRunning {
		return errors.New("core is already running")
	}

	// Parse configuration
	config, err := serial.LoadJSONConfig(strings.NewReader(string(configBytes)))
	if err != nil {
		return fmt.Errorf("failed to parse config: %v", err)
	}

	// Create core instance
	instance, err := core.New(config)
	if err != nil {
		return fmt.Errorf("failed to create core instance: %v", err)
	}

	// Start the core
	if err := instance.Start(); err != nil {
		return fmt.Errorf("failed to start core: %v", err)
	}

	x.coreInstance = instance
	x.IsRunning = true

	// Get stats manager
	if statsManager := instance.GetFeature(statsFeature.ManagerType()); statsManager != nil {
		x.statsManager = statsManager.(statsFeature.Manager)
	}

	return nil
}

// StopLoop stops the Xray core
func (x *CoreController) StopLoop() error {
	x.doShutdown()
	return nil
}

// doShutdown shuts down the Xray instance and cleans up resources
func (x *CoreController) doShutdown() {
	x.coreMutex.Lock()
	defer x.coreMutex.Unlock()
	
	if x.coreInstance != nil {
		x.coreInstance.Close()
		x.coreInstance = nil
	}
	
	x.IsRunning = false
	x.statsManager = nil
	
	// Close FastDNS resources
	if x.fastDNSManager != nil {
		x.fastDNSManager.Close()
	}
}

// CheckVersionX returns the Xray core version
func CheckVersionX() string {
	return core.Version()
}

// FastDNS related methods

// ResolveDomainFast resolves a domain using FastDNS for high-performance DNS resolution
func (x *CoreController) ResolveDomainFast(domain string) ([]string, error) {
	if x.fastDNSManager == nil {
		return nil, errors.New("FastDNS manager not initialized")
	}
	
	ips, err := x.fastDNSManager.ResolveDomain("cloudflare", domain)
	if err != nil {
		return nil, err
	}
	
	var ipStrings []string
	for _, ip := range ips {
		ipStrings = append(ipStrings, ip.String())
	}
	
	return ipStrings, nil
}

// MeasureDNSLatencyFast measures DNS resolution latency using FastDNS
func (x *CoreController) MeasureDNSLatencyFast(domain string) (int64, error) {
	if x.fastDNSManager == nil {
		return -1, errors.New("FastDNS manager not initialized")
	}
	
	latency, err := x.fastDNSManager.MeasureDNSLatency("cloudflare", domain)
	if err != nil {
		return -1, err
	}
	
	return latency.Milliseconds(), nil
}

// IsFastDNSEnabled returns whether FastDNS is enabled and available
func (x *CoreController) IsFastDNSEnabled() bool {
	if x.fastDNSManager == nil {
		return false
	}
	return x.fastDNSManager.IsEnabled()
}

// GetFastDNSResolverCount returns the number of active FastDNS resolvers
func (x *CoreController) GetFastDNSResolverCount() int {
	if x.fastDNSManager == nil {
		return 0
	}
	return x.fastDNSManager.GetResolverCount()
}

// AddFastDNSResolver adds a new FastDNS resolver
func (x *CoreController) AddFastDNSResolver(name string, resolverIP string) error {
	if x.fastDNSManager == nil {
		return errors.New("FastDNS manager not initialized")
	}
	return x.fastDNSManager.AddResolver(name, resolverIP)
}

// Global FastDNS functions for direct access

// ResolveDomainFastGlobal resolves a domain using the global FastDNS manager
func ResolveDomainFastGlobal(domain string) ([]string, error) {
	manager := GetFastDNSManager()
	if manager == nil {
		return nil, errors.New("global FastDNS manager not initialized")
	}
	
	ips, err := manager.ResolveDomain("cloudflare", domain)
	if err != nil {
		return nil, err
	}
	
	var ipStrings []string
	for _, ip := range ips {
		ipStrings = append(ipStrings, ip.String())
	}
	
	return ipStrings, nil
}

// MeasureDNSLatencyFastGlobal measures DNS latency using the global FastDNS manager
func MeasureDNSLatencyFastGlobal(domain string) (int64, error) {
	manager := GetFastDNSManager()
	if manager == nil {
		return -1, errors.New("global FastDNS manager not initialized")
	}
	
	latency, err := manager.MeasureDNSLatency("cloudflare", domain)
	if err != nil {
		return -1, err
	}
	
	return latency.Milliseconds(), nil
}

// InitCoreEnv initializes the core environment
func InitCoreEnv(envPath string) {
	if envPath != "" {
		os.Setenv("XRAY_LOCATION_ASSET", envPath)
	}
}